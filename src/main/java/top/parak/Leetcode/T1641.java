package top.parak.Leetcode;

/**
 * @author KHighness
 * @since 2021-03-29
 * @apiNote 1641. 统计字典序元音字符串的数目
 */
public class T1641 {

    /**
     * 动态规划
     * dp[i][0]~dp[i][4]表示字符串长度为(i + 1)且以a~u开头的所有满足提议的字符串数量
     * dp[i][0]即长度为(i+1)且以a开头的字符串，a后面可以连接长度为(i)且以{a, e, i, o, u}开头的字符串
     * dp[i][1]即长度为(i+1)且以e开头的字符串，a后面可以连接长度为(i)且以{e, i, o, u}开头的字符串
     * dp[i][2]即长度为(i+1)且以i开头的字符串，a后面可以连接长度为(i)且以{i, o, u}开头的字符串
     * dp[i][3]即长度为(i+1)且以o开头的字符串，a后面可以连接长度为(i)且以{o, u}开头的字符串
     * dp[i][4]即长度为(i+1)且以u开头的字符串，a后面可以连接长度为(i)且以{u}开头的字符串
     * 状态转移方程：
     * dp[i][k] = E(dp[i-1][n]) (k <= n <= 4)
     */
    public int countVowelStrings(int n) {
        int[][] dp = new int[n][5];
        for (int i = 0; i < 5; i++) {
            dp[0][i] = 1;
        }
        for (int i = 1; i < n; i++) {
            dp[i][0] = dp[i-1][0] + dp[i-1][1] + dp[i-1][2] + dp[i-1][3] + dp[i-1][4];
            dp[i][1] = dp[i-1][1] + dp[i-1][2] + dp[i-1][3] + dp[i-1][4];
            dp[i][2] = dp[i-1][2] + dp[i-1][3] + dp[i-1][4];
            dp[i][3] = dp[i-1][3] + dp[i-1][4];
            dp[i][4] = dp[i-1][4];
        }
        int ans = 0;
        for (int i = 0; i < 5; i++) {
            ans += dp[n-1][i];
        }
        return ans;
    }

    /**
     * 排列组合
     * （1）将n个球放入m个盒子中，盒子不为空
     *     <=> n个球产生n - 1个缝隙，m个盒子都不空需要m - 1个挡板
     *     => C(n - 1, m- 1)
     * （2）将n个球放入m个盒子中，盒子可以空
     *     <=> 先将m个球放入m个盒子中，后将n个球放入m个盒子中，盒子不为空
     *     <=> 将(m + n)个球放入m个盒子中，盒子不为空
     *     => C(m + n - 1, m- 1)
     * （3）那么本题等价于，将n个字符串放入m个盒子中，其中m = 5，盒子可以为空
     *     => C(5 + n - 1, 5 - 1)
     *     => C(n + 4, 4)
     *     => (n + 4)! / [4! * (n + 4 - 4)!]
     *     => (n + 4) * (n + 3) * (n + 2) * (n + 1) / 24
     */
    public int countVowelStrings2(int n) {
        return (n + 4) * (n + 3) * (n + 2) * (n + 1) / 24;
    }

}
